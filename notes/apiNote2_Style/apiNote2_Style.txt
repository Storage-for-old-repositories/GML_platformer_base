
-- ###################################################################################################################################################################################################################### --
-- ###################################################################################################################################################################################################################### --
[INFO]

	- вы можете нарушать стиль описанный ниже в зависимости от ситуации, где очевиднее использовть другой стиль

-- ########################################################################################## --
# конструкция if
	
	- допускаются практически все варианты использование

	- полный if
	- рекомендуемый
	if (cond) {
		// code
	}
	else {
		// code
	}
	
	
	- рекомендуемый
	if (cond)
		// code
	else
		// code
	
	
	if (cond)
		// code
	else {
		// code
	}
	
	
	- частичный if
	- рекомендуемый
	if (cond) {
		// code
	}
	
	
	if (cond) // code
	
	
	- рекомендуемый
	if (cond) 
		// code
	
	
	- ветвление if
	- рекомендуемый
	if (cond) {
		// code
	}
	else
	if (cond) {
		// code
	}
	
	
	if (cond) // code
	else
	if (cond) // code
	
	
	if (cond) {
		// code
	}
	else
	if (cond) // code
	else
	if (cond) {
		// code
	}

-- ########################################################################################## --
# конструкция while


	while (cond) {
		//code
	}
	
	
	while (cond) // code
	
	
	while (cond) 
		// code
	
	
	while (true) {
	
	}
	
	
	while (true) // code
	
	
	while (true) 
		// code
	
-- ########################################################################################## --
# конструкция for
	
	
	for (..;..;..) {
		// code
	}
	
	
	for (..;..;..) // code
	
	
	for (..;..;..) 
		// code
	
	
	- не допускается, используйте <while (true)>
	for (;;)
	
-- ########################################################################################## --
# конструкция do-until
	
	
	do {
		// code
	} until (cond);
	
	
	do {
		// code
	} until (true);
	
	
	do {
		// code
	} until (false);

-- ########################################################################################## --
# конструкция repeat
	
	
	- <expt> - константа или выражение
	
	
	repeat (expt) {
		// code
	}
	
	
	repeat (expt) // code
	
	
	repeat (expt)
		// code

-- ########################################################################################## --
# логические операторы

	- допускается миксование (||, &&, ^^) и (and, or, xor)
	- and, or являются ленивыми операциями

-- ########################################################################################## --
# тернарный оператор

	- тернарный оператор обязан быть взят в скобки
	(a ? b : c) - так же является ленивым оператором
	
	a = (cond ? is_true : is_false);
	
	a = (cond
		? is_true
		: is_false
	);

	- вложенные тернарные операторы не рекомендуются

-- ########################################################################################## --
# объявление функций

	- <Function Declaration> используются только файлах скриптов на самом верхнем уровне, 
	- в иных случаях должны использоватся методы <Function Expression>
	
	- <Function Declaration> гарантирует, что функция инициализированна до момента исполнения основного кода
	
	- однако объявление функция в стиле <Function Declaration> в объекта (а так же некоторых других ситуациях),
	- является обычным <Function Expression> (по крайней мере в версии 2.3.3)

-- ########################################################################################## --
# Инициализация структур

	var ar = [0, 1, 2];
	var ar = [
		0,
		1,
	];

	var struct = {name: "hello", mark: true};
	var struct = {
		name: "hello",
		mark: true
	};

-- ########################################################################################## --
# return

	return const;
	return (expr);

-- ########################################################################################## --
# доступ к массивам

	- сахарный доступ
	array = [1, 2];
	value = array[i];   // get
	array[@ i] = value; // set

	- запрещено использовать особенность массивов - псевдо-типаж copy 
	var array = [1, 2];
	var array2 = array;
	array[0] = array[0]; // в данном случаи произойдёт клонирование массива с глубинной вложености 1

	- либо используйте array_set/get

-- ########################################################################################## --
# доступ к другим структурам не имеет ограничений

	struct[$ key]
	grid[# xkey, ykey]
	map[? key]

	- можно использовать как акксесоры так и функции напрямую

-- ########################################################################################## --
# порядок вычислений

	- запрещенно, так как компилятор не гарантирует сохранения порядка вычислений при вызовах функций
	call(i++, i++, f(), f());
	var array = [i++, i++, f(), f()]; // сахар над функцией
	var struct = {k0: i++, k1: i++, k2: f(), k3: f()}; // сахар над функцией

	- функция f требует объяснений, но их не будет. Опытные пользователи и так поймут в чём тут дело, а именно в том, что нет гарантии сохранения порядка вычислений
	- если функция f чистая, то конечно её можно тут применить

-- ########################################################################################## --
# рекурсия

	- в api настоятельно не рекомендуется использовать рекурсию (пока не добавят хвостовую оптимизацию - тоесть никогда)
	- к тому же любой (возможно нет) алгоритм можно выразить через цикл

-- ########################################################################################## --
# прочее

	- пожалуйста не делайте DSL в большом количестве
	- пожалуйста используйте ;
	- пожалуйста не используйте with (all)

